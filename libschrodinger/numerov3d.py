# This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
# under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
# 
# # No Kill Do No Harm Licence â€“ Summary
# 
# Based on version 0.3, July 2022 of the Do No Harm License
# 
# https://github.com/raisely/NoHarm
# 
# LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
# 
# ## Licence Grants
# 
# You're allowed
# 
# - to distribute the licensed work,
# - to create, publish, sublicense and patent derivative works and
# - to put your modifications or your derivative work under a seperate licence,
# 
# free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
# 
# ## Unethical Behaviour
# 
# You may not use the licensed work if you engage in:
# 
# - human rights violations,
# - environmental destruction,
# - warfare,
# - addictive/destructive products or services or
# - actions that frustrate:
#   * peace,
#   * access to human rights,
#   * peaceful assembly and association,
#   * a sustainable environment or
#   * democratic processes
#   * abortion
#   * euthanasia
#   * human embryonic stem cell research (if human organisms are killed in the process)
# - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
#   * abortion
#   * euthanasia
#   * killing
# and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
# 
# ## Contributions
# 
# Contributions to the licensed work must be licensed under the exact same licence.
# 
# ## Licence Notice
# 
# When distributing the licensed work or your derivative work, you must
# 
# - include a copy of this licence,
# - retain attribution notices,
# - state changes that you made and
# - not use the names of the author and the contributors to promote your derivative work.
# 
# If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
# 
# - a "NOTICE" file within your derivative work,
# - a place within the source code or the documentation or
# - a place within a display generated by your derivative work.
# 
# ## No Warranty or Liability
# 
# The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility.
#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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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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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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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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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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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

import types
from enum import Enum
from functools import partial
import numpy as np
import importlib.util
cupy_loader = importlib.util.find_spec('cupy')
if cupy_loader is not None: 
    import cupy as cp
import matplotlib.pyplot as plt
from scipy.linalg import eigh_tridiagonal
#from scipy import sparse
#from scipy.sparse.linalg import eigsh
import scipy.sparse.linalg as scipylin
if cupy_loader is not None: 
    import cupyx.scipy.sparse.linalg as cplin

if cupy_loader is not None: 
    import cupyx.scipy.sparse as cpsparse
import scipy.sparse as scipysparse

class EigenValueTypes(Enum):
    LARGEST_MAGNITUDE = "LM"
    SMALLEST_MAGNITUDE = "SM"
    LARGEST_ALGEBRAIC = "LA"
    SMALLEST_ALGEBRAIC = "SA"
    HALF_SPECTRUM = "BE"

class DimensionIndex(Enum):
    X = 0
    Y = 1
    Z = 2
    W = 3

class WaveFunctions:
    def __init__(
                self, 
                shape : tuple[int], 
                energyValues : np.array, 
                eigenVectors : np.ndarray, 
                doNotComputeExtra : bool = False
            ):
        self.shape : tuple[int] = shape
        self.pointCount = shape[0]
        self.dimensions = len(shape)
        self.energyValues : np.array = energyValues
        self.waveFunctions : np.ndarray = np.array(list(map(
                lambda transposedWaveFunction : transposedWaveFunction.reshape(self.shape), 
                eigenVectors.T
            )))
        if doNotComputeExtra == True: 
            self.probabilities = None
            self.decibleProbabilities = None
        else: 
            self.probabilities = self.waveFunctions * np.conjugate(self.waveFunctions)
            self.decibleProbabilities = 10 * np.log10(self.probabilities)

class MeshGrid: 
    def __init__(self, gridDimensionalComponents : tuple[np.ndarray], pointCount : int, length : float): 
        self.pointCount = pointCount
        self.length = length
        self.gridDimensionalComponents : tuple[np.ndarray] = gridDimensionalComponents 
        self.dimensions = len(self.gridDimensionalComponents)
        for dimension_ in list(DimensionIndex.__members__): 
            dimension = getattr(DimensionIndex, dimension_)
            if self.dimensions > dimension.value: 
                setattr(self, dimension.name.lower(), self.gridDimensionalComponents[dimension.value])
        self.asArray = None
    def toArray(self) -> np.array: 
        self.asArray = np.column_stack(np.array([
                component.ravel() \
                for component in self.gridDimensionalComponents
            ])).ravel()
        return self.asArray

def makeLinspaceGrid(pointCount : int, length : float, dimensions : int, halfSpaced = False, componentType : type = float) -> MeshGrid: 
    if halfSpaced == True: 
        spaces : tuple[np.array] = tuple((np.linspace(-length / 2, length  / 2, pointCount, dtype = componentType) for ii in range(dimensions)))
    else: 
        spaces : tuple[np.array] = tuple((np.linspace(0, length, pointCount, dtype = componentType) for ii in range(dimensions)))
    return MeshGrid(np.meshgrid(*spaces), pointCount, length)

def makeMappingMatrix(pointCount : int, dimensions : int, gpuAccelerated = True, A = False) -> np.ndarray:
    ones = np.ones([pointCount])
    sparse = cpsparse if gpuAccelerated else scipysparse
    baseMappingMatrix = sparse.spdiags(
            np.array([ones, -2 * ones, ones]), 
            np.array([-1, 0, 1]), 
            pointCount, 
            pointCount
        )
    if A: 
        mappingMatrix  = sparse.kronsum(baseMappingMatrix, baseMappingMatrix)
        mappingMatrix  = sparse.kronsum(mappingMatrix, baseMappingMatrix)
        #I = sparse.identity(pointCount)
        #mappingMatrix = sparse.kron(sparse.kron(baseMappingMatrix, I), I) \
        #        + sparse.kron(sparse.kron(I, baseMappingMatrix), I) \
        #        + sparse.kron(sparse.kron(I, I), baseMappingMatrix)
    else: 
        mappingMatrix = baseMappingMatrix
        for ii in range(1, dimensions): 
            mappingMatrix = sparse.kronsum(mappingMatrix, baseMappingMatrix)
    return mappingMatrix, baseMappingMatrix

def kineticEnergyOperator(mappingMatrix : np.ndarray) -> np.ndarray: 
    return (-1.0 / 2.0) * mappingMatrix

def potentialEnergyOperator(potential : np.ndarray, pointCount : int, dimensions : int, gpuAccelerated = True) -> np.ndarray: 
    sparse = cpsparse if gpuAccelerated else scipysparse
    return sparse.diags(potential.reshape(pointCount ** dimensions), (0))

def makeHamiltonian(
            potential : np.ndarray, 
            pointCount : int, 
            dimensions : int, 
            mappingMatrix : np.ndarray, 
            gpuAccelerated = False
        ) -> np.ndarray: 
    return kineticEnergyOperator(mappingMatrix) + potentialEnergyOperator(
            potential, 
            pointCount, 
            dimensions, 
            gpuAccelerated
        )

def computeWaveFunction(
            potential : np.ndarray, 
            energyCount : int = 10, 
            eigenValueType : EigenValueTypes = EigenValueTypes.LARGEST_MAGNITUDE, # EigenValueTypes.SMALLEST_MAGNITUDE
            #center = 0, 
            gpuAccelerated = True, 
            A = True
        ) -> WaveFunctions: 
    dimensions : int = len(potential.shape)
    pointCount : int = potential.shape[0]
    for cardinality in potential.shape: 
        assert cardinality == pointCount, "All dimensions of potential need to have the same number of elements"
    mappingMatrix, _ = makeMappingMatrix(pointCount, dimensions, gpuAccelerated, A)
    hamiltonian = makeHamiltonian(potential, pointCount, dimensions, mappingMatrix, gpuAccelerated)
    if gpuAccelerated == False: 
        print("GPU Acceleration OFF")
        eigenStates = scipylin.eigsh( 
                hamiltonian, 
                k = energyCount, 
                which = eigenValueType.value
            )
                #sigma = #sigma
    else: 
        eigenStates = cplin.eigsh(
                hamiltonian, 
                k = energyCount, 
                which = eigenValueType.value, 
            )
    eigenValues = eigenStates[0]
    eigenVectors = eigenStates[1]
    return WaveFunctions(
            potential.shape, 
            eigenValues, 
            eigenVectors.get() if gpuAccelerated else eigenVectors
        )

